<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Ashes</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="/">
  <link rel="alternate" type="application/rss+xml" title="Ashes" href="/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Ashes</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <!-- 遍历分页后的文章 -->

  <h1><a href="/jekyll/update/2018/05/16/http.html">HTTP</a></h1>
  <p class="author">
    <span class="date">16 May 2018</span>
  </p>
  <!--<div class="content">-->
    <!--<ul>
  <li>0.2 算法</li>
  <li>0.3 python(进程线程 装饰器 迭代器生成器)</li>
  <li>
    <p>0.4 书(兼职of)</p>
  </li>
  <li>
    <ol>
      <li>http(cookie&amp;session get&amp;post&amp;head&amp;.. osi tcp三次四次)</li>
    </ol>
  </li>
  <li>1.1 tcp(tcp粘包 time_wait)</li>
  <li>1.2 tcpdump</li>
  <li>1.3. nginx</li>
  <li>
    <ol>
      <li>mysql(索引结构类型 优化 分布式问题)</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>linux(<a href="https://mp.weixin.qq.com/s/teB7KCaid8aZxuPeIOLZUA">监控</a>)</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>分布式问题 解决</li>
    </ol>
  </li>
  <li>
    <ol>
      <li></li>
    </ol>
  </li>
</ul>

<h1 id="get-post-head-put-delete-options-trace">get post head put delete options trace</h1>

<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>post提交数据方式 form-data</td>
          <td>x-www-form-urlencoded</td>
          <td>binary</td>
          <td>raw(Text</td>
          <td>text/plain</td>
          <td>application/json</td>
          <td>application/javascript</td>
          <td>application</td>
          <td>xml</td>
          <td>text/xml</td>
          <td>text/html)</td>
        </tr>
      </tbody>
    </table>

    <p>python requests库使用,加header requests.post(url, data=raw_data, headers={‘Content-Type’: ‘application/x-www-form-urlencoded’})</p>

    <p>高级用法<a href="http://docs.python-requests.org/zh_CN/latest/user/advanced.html#advanced">文档</a></p>
  </li>
</ul>

<h1 id="httphttpsblogcsdnnethuwei2003articledetails70139062">http状态码<a href="https://blog.csdn.net/huwei2003/article/details/70139062">详解</a></h1>
<ul>
  <li>
    <p>304 未修改: 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>  REASON_PHRASES = {
      100: 'CONTINUE',
      101: 'SWITCHING PROTOCOLS',
      102: 'PROCESSING',
      200: 'OK',                                      # 请求没问题,实体的主体部分包含了所请求的资源
      201: 'CREATED',
      202: 'ACCEPTED',
      203: 'NON-AUTHORITATIVE INFORMATION',
      204: 'NO CONTENT',
      205: 'RESET CONTENT',
      206: 'PARTIAL CONTENT',
      207: 'MULTI-STATUS',
      208: 'ALREADY REPORTED',
      226: 'IM USED',
      300: 'MULTIPLE CHOICES',
      301: 'MOVED PERMANENTLY',                       # 永久重定向
      302: 'FOUND',
      303: 'SEE OTHER',
      304: 'NOT MODIFIED',                            # 客户端get请求,而最近资源未被修改,可用来说明资源未被修改.响应不应该包含实体的主体部分
      305: 'USE PROXY',
      306: 'RESERVED',
      307: 'TEMPORARY REDIRECT',
      308: 'PERMANENT REDIRECT',
      400: 'BAD REQUEST',
      401: 'UNAUTHORIZED',
      402: 'PAYMENT REQUIRED',
      403: 'FORBIDDEN',
      404: 'NOT FOUND',
      405: 'METHOD NOT ALLOWED',
      406: 'NOT ACCEPTABLE',
      407: 'PROXY AUTHENTICATION REQUIRED',
      408: 'REQUEST TIMEOUT',
      409: 'CONFLICT',
      410: 'GONE',
      411: 'LENGTH REQUIRED',
      412: 'PRECONDITION FAILED',
      413: 'REQUEST ENTITY TOO LARGE',
      414: 'REQUEST-URI TOO LONG',
      415: 'UNSUPPORTED MEDIA TYPE',
      416: 'REQUESTED RANGE NOT SATISFIABLE',
      417: 'EXPECTATION FAILED',
      418: "I'M A TEAPOT",
      422: 'UNPROCESSABLE ENTITY',
      423: 'LOCKED',
      424: 'FAILED DEPENDENCY',
      426: 'UPGRADE REQUIRED',
      428: 'PRECONDITION REQUIRED',
      429: 'TOO MANY REQUESTS',
      431: 'REQUEST HEADER FIELDS TOO LARGE',
      500: 'INTERNAL SERVER ERROR',
      501: 'NOT IMPLEMENTED',
      502: 'BAD GATEWAY',
      503: 'SERVICE UNAVAILABLE',
      504: 'GATEWAY TIMEOUT',
      505: 'HTTP VERSION NOT SUPPORTED',
      506: 'VARIANT ALSO NEGOTIATES',
      507: 'INSUFFICIENT STORAGE',
      508: 'LOOP DETECTED',
      510: 'NOT EXTENDED',
      511: 'NETWORK AUTHENTICATION REQUIRED',
  }
</code></pre>
    </div>
  </li>
</ul>

<h1 id="tcp-3-4-timewait">tcp 3次握手 4次挥手 TIMEWAIT</h1>

<ul>
  <li>
    <p>3次握手是建立连接时:</p>
  </li>
  <li>
    <p>4次挥手是结束连接时:</p>
  </li>
</ul>

<h1 id="tcp">tcp粘包的问题</h1>

<h1 id="tcp-">tcp拥塞控制 慢启动</h1>

<h1 id="section">编解码</h1>
<p>## Unicode UTF8 ASCII GBK</p>

<h1 id="osiopen-system-interconnection">osi(open system interconnection)七层模型:</h1>

<ul>
  <li>
    <p>从下到上依次为:</p>

    <p>物理层(物理设备,光纤) 链路层(交换机) 网络层(ip,网关,路由器) 传输层(端口,tcp udp) 会话层 表示层(编码解码,安全,压缩) 应用层(http ftp dns)</p>
  </li>
</ul>

<h1 id="https">https原理</h1>

<ul>
  <li>
    <p>https = http + ssl/tls</p>

    <p>ssl(socket security layer)/tls(transport layer security) 传输层安全协议</p>

    <p>1.client发起请求,server返回证书及公钥
2.client产生随机密钥(用来对称加密通信).client使用公钥对该随机数加密,然后发送给server
3.server通过私钥对该报文解密,使用该随机数进行通信
4.之后的通信使用对称加密</p>
  </li>
</ul>

<h2 id="charles">charles抓包原理</h2>
-->
  <!--</div>-->

  <h1><a href="/jekyll/update/2018/05/16/http-code.html">HTTP-code</a></h1>
  <p class="author">
    <span class="date">16 May 2018</span>
  </p>
  <!--<div class="content">-->
    <!--<h1 id="section">状态码</h1>
<ul>
  <li>
    <p>http(s)请求中经常可以看到各类状态码,详解如下</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>  REASON_PHRASES = {
      100: 'CONTINUE',
      101: 'SWITCHING PROTOCOLS',
      102: 'PROCESSING',

      # 请求没问题,实体的主体部分包含了所请求的资源
      200: 'OK',

      201: 'CREATED',
      202: 'ACCEPTED',
      203: 'NON-AUTHORITATIVE INFORMATION',
      204: 'NO CONTENT',
      205: 'RESET CONTENT',

      # 成功执行了一个部分或range请求
      206: 'PARTIAL CONTENT',

      207: 'MULTI-STATUS',
      208: 'ALREADY REPORTED',
      226: 'IM USED',
      300: 'MULTIPLE CHOICES',

      # 永久重定向
      301: 'MOVED PERMANENTLY',

      # 临时重定向
      302: 'FOUND',

      303: 'SEE OTHER',

      # 客户端get请求,而最近资源未被修改,可用来说明资源未被修改.
        响应不应该包含实体的主体部分(不会返回网页内容,自从上次抓取后网页没有变更,
        进而节省带宽和开销)
      304: 'NOT MODIFIED',

      305: 'USE PROXY',
      306: 'RESERVED',
      307: 'TEMPORARY REDIRECT',
      308: 'PERMANENT REDIRECT',
      400: 'BAD REQUEST',
      401: 'UNAUTHORIZED',
      402: 'PAYMENT REQUIRED',
      403: 'FORBIDDEN',
      404: 'NOT FOUND',
      405: 'METHOD NOT ALLOWED',
      406: 'NOT ACCEPTABLE',
      407: 'PROXY AUTHENTICATION REQUIRED',
      408: 'REQUEST TIMEOUT',
      409: 'CONFLICT',
      410: 'GONE',
      411: 'LENGTH REQUIRED',
      412: 'PRECONDITION FAILED',
      413: 'REQUEST ENTITY TOO LARGE',
      414: 'REQUEST-URI TOO LONG',
      415: 'UNSUPPORTED MEDIA TYPE',
      416: 'REQUESTED RANGE NOT SATISFIABLE',
      417: 'EXPECTATION FAILED',
      418: "I'M A TEAPOT",
      422: 'UNPROCESSABLE ENTITY',
      423: 'LOCKED',
      424: 'FAILED DEPENDENCY',
      426: 'UPGRADE REQUIRED',
      428: 'PRECONDITION REQUIRED',
      429: 'TOO MANY REQUESTS',
      431: 'REQUEST HEADER FIELDS TOO LARGE',
      500: 'INTERNAL SERVER ERROR',

      # 客户端发起的请求超出服务器的能力范围(比如,使用了服务器不支持的请求方法)
      501: 'NOT IMPLEMENTED',

      # 网关错误,找不到后端服务
      502: 'BAD GATEWAY',

      # 一般是服务器有bug
      503: 'SERVICE UNAVAILABLE',

      # 服务器处理时间太长,超时
      504: 'GATEWAY TIMEOUT',

      505: 'HTTP VERSION NOT SUPPORTED',
      506: 'VARIANT ALSO NEGOTIATES',
      507: 'INSUFFICIENT STORAGE',
      508: 'LOOP DETECTED',
      510: 'NOT EXTENDED',
      511: 'NETWORK AUTHENTICATION REQUIRED',
  }
</code></pre>
    </div>
  </li>
</ul>

-->
  <!--</div>-->

  <h1><a href="/jekyll/update/2018/05/16/struct.html">基础数据结构</a></h1>
  <p class="author">
    <span class="date">16 May 2018</span>
  </p>
  <!--<div class="content">-->
    <!--<h1 id="jumphttpsalgorithmyuanbinmezh-hansbasicsdatastructurestringhtml">数据结构<a href="https://algorithm.yuanbin.me/zh-hans/basics_data_structure/string.html">jump</a></h1>

<ul>
  <li>str线程安全: 线程安全就是多线程访问时，采用了加锁机制; 线程不安全: 有可能出现多个线程先后更改数据造成所得到的数据是脏数据</li>
</ul>

<h2 id="section">可以尝试实现如下结构:</h2>
<ul>
  <li>heap; 优先队列; 霍夫曼压缩编码;</li>
</ul>

<h1 id="section-1">一些问题:</h1>
<ul>
  <li>最小生成树问题</li>
  <li>单源最短路径</li>
</ul>

<h3 id="section-2">堆</h3>
<ul>
  <li>从存储结构上来说,堆是链表存储的; 从逻辑结构上来说,堆是一颗完全二叉树. 构建堆的时候即创建一个链表, 但是要满足 a[k] &lt;= a[2<em>k+1] &amp; a[k] &lt;= a[2</em>k+2]</li>
  <li>优先队列可以使用堆结构来实现; 双端队列实现 collections.deque</li>
</ul>

<h3 id="section-3">栈</h3>
<ul>
  <li>collections.deque()</li>
</ul>

<h3 id="set">set</h3>
<ul>
  <li>
    <p>Python的set跟dict的Implementation方式类似， 可以认为set是只有key的dict. set可进行比较</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>  a = {x for x in 'abracadabra' if x not in 'abc'}
  isinstance(a, set)
</code></pre>
    </div>
  </li>
</ul>

<h3 id="section-4">哈希表</h3>
<ul>
  <li>散列表,python中即dict. 哈希冲突 f(k1)==f(k2),解决办法:开发定址法和链地址法. 查找或者插入的情况在大多数情况下可以达到O(1)</li>
</ul>

<h3 id="section-5">图</h3>
<ul>
  <li>图的表示通常使用邻接矩阵和邻接表</li>
  <li>邻接矩阵: 逻辑结构分为两部分：V和E集合。因此，用一个一维数组存放图中所有顶点数据；用一个二维数组存放顶点间关系（边或弧）的数据，这个二维数组称为邻接矩阵。邻接矩阵又分为有向图邻接矩阵和无向图邻接矩阵</li>
</ul>

<h3 id="section-6">链表操作</h3>

<div class="highlighter-rouge"><pre class="highlight"><code># 单向链表反转:
def reverse(self, head):
	prev = None
	while head.next:
		temp = head.next
		head.next = prev
		prev = head
		head = temp

	return prev

# 链表有环
def has_circle(self, head):
	fast = head
	slow = head
	while (flast and slow):
		fast = fast.next
		slow = slow.next
		if fast:
			fast = fast.next
		if fast == slow:
			break
	if fast and slow and fast == slow:
		return true
	else:
		return false

# 双向链表反转
def dreverse(self, head):
	curt = None
	while head:
		curt = head
		head = curt.next
		curt.next = curt.prev
		curt.prev = head
</code></pre>
</div>

<h3 id="section-7">二叉树</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>class Node():
	def __init__(self, item):
		self.item = item
		self.left = None
		self.right = None

class BinTree():
	def __init__(self):
		self.root = None

	def add(self, item):
		node = Node(item)
		if self.root is None:
			self.root = node
			return

		q = [self.root]
		while True:
			pop_node = q.pop(0)
			if pop_node.left is None:
				pop_node.left = node
				return

			if pop_node.right is None:
				pop_node.right = node
				return

			q.append(pop_node.left)
			q.append(pop_node.right)

	def traverse(self):
		if self.root is None:
			return []

		res = [self.root.item]
		q = [self.root]
		while q != []:
			pop_node = q.pop(0)
			if pop_node.left:
				q.append(pop_node.left)
				res.append(pop_node.left.item)

			if pop_node.right:
				q.append(pop_node.right)
				res.append(pop_node.right.item)

		return res

	def preorder(self, root):
		if root is None:
			return []

		f = [root.item]
		m = self.preorder(root.left)
		e = self.preorder(root.right)

		return f + m + e
</code></pre>
</div>

-->
  <!--</div>-->

  <h1><a href="/jekyll/update/2018/05/16/algorithm.html">基础算法</a></h1>
  <p class="author">
    <span class="date">16 May 2018</span>
  </p>
  <!--<div class="content">-->
    <!--<h1 id="httpcodevscnproblemset">算法<a href="http://codevs.cn/problemset/">题库</a></h1>

<ul>
  <li><a href="https://algorithm.yuanbin.me/zh-hans/basics_sorting/">goods</a></li>
</ul>

<h2 id="httpwuchongmeblog20140209algorithm-sort-summary">排序<a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/">参考</a></h2>
<ul>
  <li><a href="https://www.cnblogs.com/onepixel/articles/7674659.html">示例</a></li>
  <li>时间复杂度 空间复杂度 稳定性(如果排序后文件中拥有相同键的项的相对位置不变，这种排序方式是稳定的)</li>
  <li>快排 nlogn	非递归写法</li>
  <li>堆排序: 大根堆,取走堆顶(实际是数组第一个元素),重新构建大顶堆,依次取走堆顶</li>
</ul>

<h3 id="section">快速排序</h3>
<div class="highlighter-rouge"><pre class="highlight"><code># 递归
def	qsort(L):
	if len(L) &lt; 2:
		return L

	return qsort([lt for lt in L[1:] if lt &lt; L[0]]) + L[0:1] + qsort(gt for gt in L[1:] if gt &gt;= L[0])
</code></pre>
</div>

<h3 id="section-1">堆排序(堆的存储结构是数组,为何还会有堆排序=&gt;是一种选择排序,比直接的选择排序快)</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>def heapsort(x):
    if not x or len(x) &lt; 2:
        return x

    a = []
    heapq.heapify(x)
    while len(x):
        top = heapq.heappop(x)
        a.append(top)
        heapq.heapify(x)

    return a
</code></pre>
</div>

<h3 id="section-2">归并排序</h3>

<h2 id="httpswwwcnblogscomyw09041432p5908444html">查找 <a href="https://www.cnblogs.com/yw09041432/p/5908444.html">示例</a></h2>

<h3 id="section-3">顺序查找</h3>

<ul>
  <li>顺序查找的时间复杂度为O(n)</li>
</ul>

<h3 id="section-4">二分查找</h3>

<ul>
  <li>
    <p>最坏情况下，关键词比较次数为log2(n+1)，且期望时间复杂度为O(log2n)；</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>  # 递归
  def bisect(a_list, n):
      low = 0
      high = len(a_list)
      mid = (low+high)//2
      if a_list[mid] &lt; n:
          bisect(a_list[mid+1:high], n)
      elif a_list[mid] &gt; n:
          bisect(a_list[low:high], n)
      else:
          return mid


  # 非递归
  def bisect(a_list, n):
      low = 0
      high = len(a_list)
      while low &lt; high:
          mid = (low+high)//2
          if a_list[mid] == n:
              return mid
          elif a_list[mid] &lt; n:
              low = mid + 1
          else:
              high = mid
</code></pre>
    </div>
  </li>
</ul>

<h3 id="section-5">插值查找</h3>
<ul>
  <li>改进 mid = (low+high)/2 为 mid=low+1/2<em>(high-low) 即 mid=low+(key-a[low])/(a[high]-a[low])</em>(high-low)</li>
</ul>

-->
  <!--</div>-->

  <h1><a href="/jekyll/update/2018/05/16/python.html">python</a></h1>
  <p class="author">
    <span class="date">16 May 2018</span>
  </p>
  <!--<div class="content">-->
    <!--<h1 id="python">python基础</h1>
<ul>
  <li>py2于2019年底停止支持</li>
</ul>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">foo</span>
  <span class="nb">puts</span> <span class="s1">'foo'</span>
<span class="k">end</span></code></pre></figure>

<h3 id="python-iter-slice-islice">python iter方法 slice类 islice方法</h3>
<ul>
  <li>iter返回一个迭代器</li>
  <li>python的迭代器为什么一定要实现__iter__方法</li>
</ul>

<h3 id="python-re">python re模块</h3>
<ul>
  <li>re.findall</li>
</ul>

<h3 id="python-xrange-range">python xrange range</h3>
<ul>
  <li>xrange() 函数用法与 range 完全相同，所不同的是生成的不是一个数组，而是一个生成器。用xrange创建一个生成器 (i for i in xrange(5))</li>
</ul>

<h3 id="python-1">python中元组的比较</h3>
<ul>
  <li>
    <p>如果比较的元素是同类型的,则比较其值,返回结果。如果两个元素不是同一种类型,则检查它们是否是数字。</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>  cmp((123, '123'), (123, '123', 1)) == -1
  cmp((223, '123'), (123, '123', 1)) == 1
</code></pre>
    </div>
  </li>
</ul>

<h3 id="pythonstring-unicode-byteshttpwwwcnblogscomonepixelarticles7357273html">python中的string unicode bytes<a href="http://www.cnblogs.com/onepixel/articles/7357273.html">示例</a></h3>
<ul>
  <li>unicode是字符集：为每一个「字符」分配一个唯一的 ID</li>
  <li>utf8是编码规则: 字节序列的规则</li>
</ul>

<h4 id="python-obj--str">python 时间obj–str转换</h4>

<ul>
  <li>
    <p>datetime转str</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>  now = datetime.datetime.now()
  now_str = now.strftime('%Y-%m-%d %H:%M:%S')
</code></pre>
    </div>
  </li>
  <li>
    <p>str转datetime</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>  datetime.datetime.strptime(now_str, "%Y-%m-%d %H:%M:%S")
</code></pre>
    </div>
  </li>
  <li>
    <p>time转str</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>  now = time.strftime("%Y-%m-%d %H:%M:%S")
</code></pre>
    </div>
  </li>
  <li>
    <p>datetime转时间戳</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>  t = time.mktime(now.timetuple())
</code></pre>
    </div>
  </li>
  <li>
    <p>时间戳转datetime</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>  t = time.time()
  datetime.datetime.fromtimestamp(t)
</code></pre>
    </div>
  </li>
</ul>

<hr />

<h3 id="python-generator">python generator</h3>
<p>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p>

<p>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器（Generator）。</p>

<p>要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>L = [x * x for x in range(10)]
L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
g = (x * x for x in range(10))
g
&lt;generator object &lt;genexpr&gt; at 0x104feab40&gt;

def my_gen():  
	n = 1  
	print('This is printed first')  
	# Generator function contains yield statements  
	yield n  

	n += 1  
	print('This is printed second')  
	yield n  

	n += 1  
	print('This is printed at last')  
	yield n  

for item in my_gen():  
	print(item) 
</code></pre>
</div>

<h3 id="python-coroutine">python coroutine</h3>
<p>python协程 一图以蔽之 <img src="https://awesome-tao.github.io/images/coroutine-simple.png" alt="图片" /></p>

<div class="highlighter-rouge"><pre class="highlight"><code>def averager():
    total = 0
	count = 0
	average = None
	while True:
	    in_num = yield average
		count += 1
		total += in_num
</code></pre>
</div>

<hr />

-->
  <!--</div>-->

  <h1><a href="/jekyll/update/2018/05/11/util.html">工具</a></h1>
  <p class="author">
    <span class="date">11 May 2018</span>
  </p>
  <!--<div class="content">-->
    <!--<h3 id="elasticsearch">elasticsearch</h3>

<ul>
  <li>
    <p>原理</p>

    <p>时间序列数据库的秘密(2)——索引<a href="http://www.infoq.com/cn/articles/database-timestamp-02?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk"></a>
  (http://www.infoq.com/cn/articles/database-timestamp-01)</p>
  </li>
</ul>

-->
  <!--</div>-->

  <h1><a href="/jekyll/update/2018/05/11/web-framework.html">web-framework</a></h1>
  <p class="author">
    <span class="date">11 May 2018</span>
  </p>
  <!--<div class="content">-->
    <!--<p><a href="https://yiyibooks.cn/xx/Django_1.11.6/topics/index.html">django中文文档</a></p>

<p><a href="https://docs.djangoproject.com/en/2.0/">django英文文档</a></p>

<h1 id="web-frameworkwhat-is-a-web-frameworkhttpsjeffknuppcomblog20140303what-is-a-web-framework">设计一个web framework需要哪些功能或组件<a href="https://jeffknupp.com/blog/2014/03/03/what-is-a-web-framework/">what-is-a-web-framework</a></h1>

<ul>
  <li>其实一个Web App，就是写一个WSGI的处理函数，针对每个HTTP请求进行响应<a href="https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0014023080708565bc89d6ab886481fb25a16cdc3b773f0000">test</a>
    <ul>
      <li>URL映射</li>
      <li>网页模板 网页缓存</li>
      <li>request response</li>
    </ul>
  </li>
</ul>

<h1 id="cap">锁 CAP原理</h1>
<ul>
  <li>分布式锁	https://www.cnblogs.com/austinspark-jessylu/p/8043726.html</li>
  <li>文件读写锁</li>
  <li>互斥锁 乐观悲观锁</li>
  <li>线程安全的实现方法</li>
  <li>进程内缓存</li>
</ul>

<h1 id="section">事务</h1>
<ul>
  <li>分布式事务</li>
</ul>

<h2 id="tips">tips</h2>

<ul>
  <li>URL拦截器</li>
</ul>

<h3 id="django">django源码分析</h3>

<h3 id="section-1">特点及同其他框架的比较</h3>

<ul>
  <li>
    <p>django有哪些有点</p>

    <ol>
      <li>
        <p>大而全</p>
      </li>
      <li>
        <p>app可插拔</p>
      </li>
      <li>
        <p>orm 写好model可直接生成表</p>
      </li>
    </ol>
  </li>
  <li>
    <p>django vs tornado</p>
  </li>
  <li>
    <p>django同步 vs. tornado异步</p>
  </li>
</ul>

<h3 id="section-2">使用</h3>

<ul>
  <li>
    <p>命令</p>

    <p>python manage.py migrate —&gt; migrate命令会查找你所有可用的模型然后在你的数据库中创建还不存在的数据库表</p>

    <p>django-admin startproject mysite —&gt; 创建一个项目</p>
  </li>
  <li>
    <p>模板过滤器</p>
  </li>
</ul>

-->
  <!--</div>-->

  <h1><a href="/jekyll/update/2018/03/14/ffmpeg.html">ffmpeg命令</a></h1>
  <p class="author">
    <span class="date">14 Mar 2018</span>
  </p>
  <!--<div class="content">-->
    <!--<h3 id="tips">tips:</h3>

<ul>
  <li>一些比较重要的参数
    <ul>
      <li>r 帧率</li>
      <li>s 裁剪尺寸</li>
      <li>b 比特率(视频清晰度)</li>
    </ul>
  </li>
  <li>
    <p>获取media信息
  ffprobe -show_format -show_streams xxx.video</p>

    <p>-gif duration</p>

    <table>
      <tbody>
        <tr>
          <td>exiftool -Duration gif_tmp_path</td>
          <td>perl -lane ‘print $1 if /: ?([0-9]+.[0-9]+)/’</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>压缩</p>

    <p>gif 转 mp4: ffmpeg -r 40 -i input.gif output.mp4 (-r参数是帧率,数值越大,播放越快)</p>

    <p>MP4转gif: ffmpeg -i output.mp4 -r 10 1233333.gif -hide_banner (-hide_banner 可以隐藏不必要的多余讯息)</p>
  </li>
</ul>

<h3 id="mediainfo-software-mediainfohttpsmediaareanetenmediainfodownloadubuntu">mediainfo software新发现 <a href="https://mediaarea.net/en/MediaInfo/Download/Ubuntu">MediaInfo</a></h3>

<ul>
  <li>
    <p>一些参数详解</p>

    <ul>
      <li>
        <p>Codec ID: mp42 isom</p>
      </li>
      <li>
        <p>Format profile: High@L3.1 High@L4.0</p>
      </li>
      <li>
        <p>Codec settings: CABAC / 4 Ref Frames ; CABAC / 5 Ref Frames</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="ffmpeg">ffmpeg命令</h3>

<ul>
  <li>视频旋转</li>
  <li>视频宽高</li>
  <li>打水印</li>
  <li>
    <p>压缩</p>
  </li>
  <li>
    <p>gt() 大于, gte() 大于等于, lt() 小于 and lte() 小于等于</p>
  </li>
  <li>ffmpeg<a href="https://www.gitbook.com/book/xdsnet/other-doc-cn-ffmpeg/details">中文文档</a></li>
  <li>
    <p>ffmpeg<a href="https://xdsnet.gitbooks.io/other-doc-cn-ffmpeg/content/ffmpeg-doc-cn-08.html">表达式计算/求值</a></p>
  </li>
  <li>
    <p>ffmpeg 码率 帧率</p>

    <ul>
      <li>
        <p>码率一般指比特率，比特率是指每秒传送的比特(bit)数。单位为 bps(Bit Per Second)，比特率越高，传送数据速度越快。</p>
      </li>
      <li>
        <p>帧率每秒显示帧数。</p>
      </li>
    </ul>
  </li>
  <li>
    <p>ffmpeg overlay用法 <a href="https://ffmpeg.org/ffmpeg-filters.html#Commands-15">filters中用法</a></p>

    <div class="highlighter-rouge"><pre class="highlight"><code>  overlay=x='if(gte(t,2), -w+(t-2)*20, NAN)':y=0

  lte(x, y)
  返回x&lt;=y判断式值，符合为1，否则为0

  gte(x, y)
  返回判断x&gt;=y的结果，符合则为1，否则为0

  if(x, y)
  判断x值，如果x值为非0，则返回y，否则返回0

  if(x, y, z)
  判断x值，如果x值为非0，则返回y，否则返回z.
</code></pre>
    </div>
  </li>
</ul>

<h3 id="python-text-img">python text-&gt;img</h3>

<ul>
  <li>
    <p>PIL<a href="http://pillow.readthedocs.io/en/latest/index.html">文档</a></p>
  </li>
  <li>
    <p>一些概念</p>

    <ul>
      <li>RGBA是代表Red（红色） Green（绿色） Blue（蓝色）和 Alpha的色彩空间，也就是透明度/不透明度。0x80是128，大约是255的一半，A为128即为50%透明度</li>
    </ul>
  </li>
  <li>
    <p>代码</p>

    <div class="highlighter-rouge"><pre class="highlight"><code>  def text2line(text, font, special_padding, ch, width=466, 
      rightpadding=12, 
      leftpadding=12):
      REPLACEMENT_CHARACTER = u'\uFFFD'

      lines = []
      line = u""
      sencond_flag = 0

      if not ch:
          text_list = text.split()
      else:
          text_list = text

      for word in text_list:
          if not ch:
              word = word + ' '
              rightpadding = 0

          if word == REPLACEMENT_CHARACTER:
              lines.append(line)
              sencond_flag = 1
              line = u""
              print line, lines
          elif sencond_flag == 0 and font.getsize(line + word)[0] &lt;= 
                  (width - rightpadding - leftpadding):
              line += word
              sencond_flag = 1
          elif sencond_flag == 1 and font.getsize(line + word)[0] &lt;= 
                  (width - rightpadding - leftpadding - special_padding):
              line += word
          else:
              lines.append(line)
              line = u""

              line += word

      if len(line) != 0:
          lines.append(line[:])  # add the last line
      line_height = font.getsize(text)[1] + 5
      img_height = line_height * (len(lines))

      return img_height, line_height, lines
  ------------------------------------------------------------------

  from PIL import Image, ImageDraw, ImageFont
  # 在图上写字
  font = ImageFont.truetype("/home/arial.ttf", 47)
  img = Image.open("/home/first-bar.png")
  draw = ImageDraw.Draw(img)
  draw.text((240, 0), word_name, '#ffffff', font=font)
  # img.show()
  ret_path = '/home/1.png'
  img.save(ret_path)
	
  # 新建空白图片写字
  font = ImageFont.truetype("/home/pingfang.ttf", 24)
  img = Image.new("RGBA", (466, 52), (0, 0, 0, 20))
  draw = ImageDraw.Draw(img)
  draw_text = "test"
  draw.text((12, 5), unicode(draw_text,'utf-8'), "#FFFFFF", font=font)
  # img.show()
  ret_path = '/home/2.png'
  img.save(ret_path)
</code></pre>
    </div>
  </li>
</ul>
-->
  <!--</div>-->

  <h1><a href="/jekyll/update/2018/03/10/flutter.html">flutter</a></h1>
  <p class="author">
    <span class="date">10 Mar 2018</span>
  </p>
  <!--<div class="content">-->
    <!--<h1 id="section">安装</h1>
<ul>
  <li>
    <p>git clone -b beta https://github.com/flutter/flutter.git</p>
  </li>
  <li>
    <p>export PATH=<code class="highlighter-rouge">pwd</code>/flutter/bin:$PATH</p>
  </li>
  <li>
    <p>flutter doctor (检测安装依赖程序)</p>
  </li>
  <li></li>
</ul>

-->
  <!--</div>-->

  <h1><a href="/jekyll/update/2018/03/10/mq.html">MQ</a></h1>
  <p class="author">
    <span class="date">10 Mar 2018</span>
  </p>
  <!--<div class="content">-->
    <!--<h1 id="mqmessage-queue">MQ即Message Queue</h1>

<ul>
  <li>部分MQ中有延迟执行(定时执行的功能). 如果时效性要求不高的话可以用crontab，每5分钟执行一次落在该时间内的任务(用cache实现)</li>
</ul>

<h3 id="nsq">nsq</h3>

<ul>
  <li>nsq中延迟执行最长为1小时后，关键字defer(deferred), MaxReqTimeout==1hour</li>
</ul>
-->
  <!--</div>-->

  <h1><a href="/jekyll/update/2018/03/06/blockchain.html">区块链</a></h1>
  <p class="author">
    <span class="date">06 Mar 2018</span>
  </p>
  <!--<div class="content">-->
    <!--<h1 id="section">区块链书籍</h1>

<ul>
  <li><a href="https://github.com/chaozh/awesome-blockchain">github区块链总结</a></li>
  <li><a href="https://yeasy.gitbooks.io/blockchain_guide/">区块链技术指南</a></li>
  <li><a href="https://mp.weixin.qq.com/s/sNoZr_tWkULURcXfF6fUaA">看完此文再不懂区块链算我输，用Python从零开始创建区块链</a></li>
  <li>
    <p><a href="http://bitcoin-on-nodejs.ebookchain.org/">Node.js开发加密货币</a></p>
  </li>
  <li>hashlib.sha1</li>
</ul>

-->
  <!--</div>-->

  <h1><a href="/jekyll/update/2018/03/05/mysql.html">数据库设计及优化</a></h1>
  <p class="author">
    <span class="date">05 Mar 2018</span>
  </p>
  <!--<div class="content">-->
    <!--<h2 id="mysql">高并发分布式下的mysql问题</h2>

<ul>
  <li>
    <p>好文<a href="https://www.cnblogs.com/shanyou/p/5048099.html?utm_source=tuicool&amp;utm_medium=referral">千万级规模高性能、高并发的网络架构经验分享</a></p>
  </li>
  <li>
    <p>mysql主从延迟的解决办法</p>
  </li>
</ul>

<h2 id="mysql-1">mysql原理</h2>

<ul>
  <li>MySQL索引
    <ul>
      <li>
        <p>聚簇索引 非聚簇索引</p>
      </li>
      <li>普通索引 唯一索引</li>
      <li>单列索引 组合索引</li>
      <li>全文索引 空间索引(MyISAM引擎才支持)</li>
      <li>覆盖索引</li>
    </ul>
  </li>
</ul>

<h2 id="mysql-">mysql 应用</h2>
<p>### 在MySQL中构建树结构</p>

<ul>
  <li>
    <p>邻接表</p>
  </li>
  <li>
    <p>递归查询</p>
  </li>
  <li>
    <p>路径枚举<a href="https://github.com/django-treebeard/django-treebeard">django-treebeard</a></p>
  </li>
  <li>
    <p>嵌套集<a href="https://en.wikipedia.org/wiki/Nested_set_model">wiki</a></p>

    <p>[django-mptt]https://github.com/django-mptt/django-mptt</p>
  </li>
  <li>
    <p>闭包表</p>
  </li>
  <li>
    <p>管理MySQL中的分层数据 <a href="http://mikehillyer.com/articles/managing-hierarchical-data-in-mysql/">Managing Hierarchical Data in MySQL</a></p>
  </li>
</ul>

<h3 id="explain">explain解析</h3>

<ul>
  <li>
    <p>select_type 表示select语句的类型</p>

    <ul>
      <li>SIMPLE 简答查询,不包括连接查询和子查询</li>
      <li>PRIMARY 主查询或者是最外层的查询语句</li>
      <li>UNION 连接查询</li>
      <li>DEPENDENT UNION</li>
      <li>UNION RESULT</li>
      <li>SUBQUERY</li>
      <li>DEPENDENT SUBQUERY</li>
      <li>DERIVED</li>
    </ul>
  </li>
  <li>
    <p>type 表的连接类型</p>

    <p>system const eq_ref ref ref_or_null index_merge unique_subquery index_subquery range index ALL</p>
  </li>
</ul>

-->
  <!--</div>-->

  <h1><a href="/jekyll/update/2018/03/01/ai.html">AI</a></h1>
  <p class="author">
    <span class="date">01 Mar 2018</span>
  </p>
  <!--<div class="content">-->
    <!--<h3 id="google-mlhttpsdevelopersgooglecommachine-learningcrash-course">google机器学习速成课程 <a href="https://developers.google.com/machine-learning/crash-course/">ML</a></h3>

<h1 id="tensorflow">tensorflow安装</h1>

<ul>
  <li><a href="https://www.tensorflow.org/install/install_linux">install_ubuntu</a></li>
</ul>
-->
  <!--</div>-->

  <h1><a href="/jekyll/update/2018/02/24/uwsgi.html">uwsgi操作</a></h1>
  <p class="author">
    <span class="date">24 Feb 2018</span>
  </p>
  <!--<div class="content">-->
    <!--<h3 id="uwsgi">uwsgi操作</h3>
-->
  <!--</div>-->

  <h1><a href="/jekyll/update/2018/02/24/stat.html">统计stat</a></h1>
  <p class="author">
    <span class="date">24 Feb 2018</span>
  </p>
  <!--<div class="content">-->
    <!--<h3 id="stat">统计stat</h3>
-->
  <!--</div>-->

  <h1><a href="/jekyll/update/2018/02/24/interview.html">interview</a></h1>
  <p class="author">
    <span class="date">24 Feb 2018</span>
  </p>
  <!--<div class="content">-->
    <!--<ul>
  <li>https://leetcode.com/</li>
  <li>http://www.lintcode.com/</li>
</ul>

<h1 id="section">算法</h1>

<ul>
  <li>
    <p>台阶问题, 每次可以跳A步, 也可跳B步, 跳n个台阶, 共有几种方法 ?</p>

    <p>iA + jB = n  即求 i + j</p>
  </li>
</ul>

<h1 id="section-1">数据结构</h1>

<h1 id="section-2">网络</h1>

<h3 id="http-https--https-">http https 区别 https 过程</h3>

-->
  <!--</div>-->

  <h1><a href="/jekyll/update/2018/02/24/goods.html">技术博客</a></h1>
  <p class="author">
    <span class="date">24 Feb 2018</span>
  </p>
  <!--<div class="content">-->
    <!--<h3 id="meituanhttpstechmeituancom">美团点评 <a href="https://tech.meituan.com/">meituan</a></h3>

<h3 id="allhttpblogcsdnnetmfcingarticledetails51577173">互联网公司的技术博客汇总 <a href="http://blog.csdn.net/mfcing/article/details/51577173">all</a></h3>
-->
  <!--</div>-->

  <h1><a href="/jekyll/update/2018/02/24/git.html">版本控制</a></h1>
  <p class="author">
    <span class="date">24 Feb 2018</span>
  </p>
  <!--<div class="content">-->
    <!--<h3 id="git">git</h3>

<ul>
  <li>git rm
  当我们需要删除暂存区或分支上的文件, 同时工作区也不需要这个文件了, 可以使用</li>
  <li>git rm –cached
  当我们需要删除暂存区或分支上的文件, 但本地又需要使用, 只是不希望这个文件被版本控制, 可以使用</li>
</ul>

-->
  <!--</div>-->

  <h1><a href="/jekyll/update/2018/02/24/cache.html">cache相关</a></h1>
  <p class="author">
    <span class="date">24 Feb 2018</span>
  </p>
  <!--<div class="content">-->
    <!--<h3 id="memcache">memcache</h3>

<ul>
  <li>
    <p>memrm/memcat –servers=test:1234 $1</p>
  </li>
  <li>
    <p>stats命令： http://yusi123.com/2833.html</p>
  </li>
  <li>
    <p>性能优化:</p>

    <p>http://blog.csdn.net/qq_30739519/article/details/51103398</p>

    <p>http://san-yun.iteye.com/blog/1591803</p>

    <p>http://blog.csdn.net/xinguan1267/article/details/7870302</p>

    <p>https://www.dexcoder.com/selfly/article/2248</p>
  </li>
  <li>
    <p>memcached 命令</p>

    <table>
      <tbody>
        <tr>
          <td>(1) memcached-tool zoo:11210</td>
          <td>memcached-tool zoo:11210 stats</td>
          <td>memcached-tool zoo:11210 dump (导数据，不要随便用)</td>
        </tr>
      </tbody>
    </table>

    <p>(2) telnet zoo 11210</p>

    <table>
      <tbody>
        <tr>
          <td>(3) stats</td>
          <td>stats items</td>
          <td>stats slabs</td>
        </tr>
      </tbody>
    </table>

    <table>
      <tbody>
        <tr>
          <td>(4) echo ‘stats slabs’</td>
          <td>nc zoo 11210</td>
        </tr>
      </tbody>
    </table>

    <table>
      <tbody>
        <tr>
          <td>lsof -nP -p 31559</td>
          <td>grep TCP -c</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h3 id="redis">redis</h3>
-->
  <!--</div>-->

  <h1><a href="/jekyll/update/2018/02/24/nginx.html">nginx操作</a></h1>
  <p class="author">
    <span class="date">24 Feb 2018</span>
  </p>
  <!--<div class="content">-->
    <!--<h3 id="nginx">nginx操作</h3>
-->
  <!--</div>-->


<!-- 分页链接 -->
<div class="pagination">
  
    <span class="previous">Previous</span>
  
  <span class="page_number ">Page: 1 of 1</span>
  
    <span class="next ">Next</span>
  
</div>
      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Ashes</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Ashes</li>
          <li><a href="mailto:"></a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
